LIBRARY ieee;
USE ieee.std_logic_1164.all;

-- TODO: change all delays to be based on a single clock

entity display_driver is
  generic
  (
    MEM_ADDR_N     : natural   := 20;     -- How wide is the memory address bus
    MEM_IO_N       : natural   := 8;      -- How wide is the memory IO bus
    LED_N          : natural   := 3;      -- Number of LEDs
    DATA_N         : natural   := 8;      -- How wide is the data bus
    DISP_N         : natural   := 8;      -- How many bits per pixel color
    DISP_DELAY     : integer   := 1000000;-- 50ms with 20MHz clock
    CYCLES         : integer   := 20000;
    PWR_DELAY      : integer   := 200000; -- 10ms with 20MHz clock
    DATA_DELAY     : integer   := DISP_DELAY-PWR_DELAY-20000;
    DEF_BRIGHTNESS : integer   := 512;
    PWM_DIVIDE     : integer   := 5;      -- Sets the PWM frequency
    PWM_MAX        : integer   := 1024   -- Sets the amount of PWM steps
  );
  port
  (
    clk           : in std_logic;
    mem_addr      : out std_logic_vector(MEM_ADDR_N-1 downto 0);
    mem_io        : inout std_logic_vector(MEM_IO_N-1 downto 0);
    mem_ce        : out std_logic; -- Memory chip enable
    mem_oe        : out std_logic; -- Memory output enable
    mem_we        : out std_logic; -- Memory write enable
    leds          : out std_logic_vector(LED_N-1 downto 0);
    data_in       : in std_logic_vector(DATA_N-1 downto 0);
    data_clk      : in std_logic;
    data_gpio     : in std_logic_vector(1 downto 0);
    disp_red      : out std_logic_vector(DISP_N-1 downto 0);
    disp_green    : out std_logic_vector(DISP_N-1 downto 0);
    disp_blue     : out std_logic_vector(DISP_N-1 downto 0);
    disp_clk      : out std_logic;
    disp_en       : out std_logic;
    disp_hsync    : out std_logic;
    disp_vsync    : out std_logic;
    disp_power    : out std_logic;
    backlight_en  : out std_logic;
    backlight_pwm : out std_logic
  );
end entity;

architecture dd of display_driver is

  signal led_states : std_logic_vector(LED_N-1 downto 0) := "100";
  signal init_done  : boolean := false;
  signal reset      : std_logic;
  signal data_on    : boolean := false;
  signal brightness : integer := DEF_BRIGHTNESS;

begin

-- Init routine which makes sure the display AVdd is powered on after +2.5V
-- and then DISP goes high after 40ms
-- Could save a lot of blocks by dividing clock...

  process(clk, reset)

    variable delay_cnt   : integer range 0 to PWR_DELAY+DISP_DELAY+DATA_DELAY;
    variable disp_on     : boolean := false;
    variable disp_en_on  : boolean := false;

  begin
    if reset = '1' then
      disp_power <= '0';
      disp_en <= '0';
      disp_on := false;
      disp_en_on := false;
      init_done <= false;
      delay_cnt := 0;
    elsif rising_edge(clk) then
      if delay_cnt = PWR_DELAY and not disp_on then
        disp_power <= '1';
        disp_on := true;
      elsif delay_cnt = DATA_DELAY+PWR_DELAY and not data_on then
        data_on <= true;
      elsif delay_cnt = DISP_DELAY+PWR_DELAY+DATA_DELAY and not disp_en_on then
        disp_en <= '1';
        disp_en_on := true;
        init_done <= true;
      elsif delay_cnt < PWR_DELAY + DISP_DELAY + DATA_DELAY then
        delay_cnt := delay_cnt + 1;
      end if;
    end if;
  end process;

-- PWM routine for the backlight 
  
  process(clk, reset)

    variable pwm_cycle_cnt   : integer range 0 to PWM_DIVIDE-1;
    variable pwm_val         : integer range 0 to PWM_MAX-1;

  begin
    if reset = '1' then
      backlight_en <= '0';
      backlight_pwm <= '0';
      pwm_cycle_cnt := 0;
      pwm_val := 0;
    elsif rising_edge(clk) then
      if pwm_val = 0 and init_done then
        backlight_pwm <= '1';
      end if;
      if pwm_cycle_cnt < PWM_DIVIDE-1 then
        pwm_cycle_cnt := pwm_cycle_cnt + 1;
      elsif pwm_val < brightness then
        pwm_val := pwm_val + 1;
        pwm_cycle_cnt := 0;
      elsif pwm_val >= brightness then
        backlight_pwm <= '0';
        pwm_cycle_cnt := 0;
      else
        pwm_val := 0;
      end if;
    end if;
  end process;

-- Scrolling LED lights, poorly done :)

  process(clk, reset)

    variable cnt : integer range 0 to CYCLES-1;

  begin

    if reset = '1' then
      cnt := 0;
      led_states <= "100";
    elsif rising_edge(clk) then
      if cnt >= CYCLES-1 then
        led_states(2) <= led_states(1);
        led_states(1) <= led_states(0);
        led_states(0) <= led_states(2);
        leds <= led_states;
        cnt := 0;
      else
        cnt := cnt + 1;
      end if;
    end if;
  end process;
end;
